<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn - Crack The Code</title>
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="stylesheet" href="/styles/learn.css">
</head>
<body>
    <nav class="navbar">
        <div class="navbar-content">
            <a href="index.html" class="logo">Crack The Code</a>
            <div class="nav-links">
                <a href="/index.html">Home</a>
                <a href="/learn.html" class="active">Learn</a>
                <a href="/code.html">Practice</a>
                <a href="/discuss.html">Reach Out</a>
            </div>
        </div>
    </nav>

    <main class="learn-container">
        <h1 class="page-title">Data Structures and Algorithms</h1>
        
        <section class="ds-grid">
            <!-- Array Section -->
            <article class="ds-card">
                <h2>Arrays</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is an Array?</h3>
                        <p>An array is a collection of elements stored at contiguous memory locations. It's the simplest data structure where each element can be accessed directly.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>When you need quick access to elements using indices</li>
                            <li>When data is naturally tabular</li>
                            <li>When you need constant-time access to elements</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>Contact lists in phones</li>
                            <li>Image pixel storage</li>
                            <li>Spreadsheet applications</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="array-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="insert">Insert</button>
                            <button class="viz-btn" data-operation="delete">Delete</button>
                            <button class="viz-btn" data-operation="search">Search</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: Array Operations

1. Initialize Array:
   array = empty array of size n

2. Insert(element):
   if array is not full:
      add element to end of array
      increment size
   else:
      return overflow error

3. Delete(index):
   if index is valid:
      shift elements after index left
      decrement size
   else:
      return invalid index error

4. Search(element):
   for i from 0 to size-1:
      if array[i] equals element:
         return i
   return not found</code></pre>
                    </section>
                </div>
            </article>

            <!-- Stack Section -->
            <article class="ds-card">
                <h2>Stack</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is a Stack?</h3>
                        <p>A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. Think of it like a stack of plates.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>Function call management (Call Stack)</li>
                            <li>Undo operations in text editors</li>
                            <li>Expression evaluation</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>Browser history</li>
                            <li>Text editor undo feature</li>
                            <li>Recursive function calls</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="stack-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="push">Push</button>
                            <button class="viz-btn" data-operation="pop">Pop</button>
                            <button class="viz-btn" data-operation="peek">Peek</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: Stack Operations

1. Initialize Stack:
   stack = empty stack
   top = -1

2. Push(element):
   if stack is not full:
      increment top
      stack[top] = element
   else:
      return overflow error

3. Pop():
   if stack is not empty:
      element = stack[top]
      decrement top
      return element
   else:
      return underflow error

4. Peek():
   if stack is not empty:
      return stack[top]
   else:
      return empty error</code></pre>
                    </section>
                </div>
            </article>

            <!-- Queue Section -->
            <article class="ds-card">
                <h2>Queue</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is a Queue?</h3>
                        <p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. Think of it like a line of people waiting.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>Task scheduling</li>
                            <li>Breadth-First Search</li>
                            <li>Print job management</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>Ticket booking systems</li>
                            <li>Call center phone systems</li>
                            <li>Printer job queues</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="queue-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="enqueue">Enqueue</button>
                            <button class="viz-btn" data-operation="dequeue">Dequeue</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: Queue Operations

1. Initialize Queue:
   queue = empty queue
   front = -1
   rear = -1

2. Enqueue(element):
   if queue is not full:
      if queue is empty:
         front = 0
      increment rear
      queue[rear] = element

3. Dequeue():
   if queue is not empty:
      element = queue[front]
      if front equals rear:
         reset front and rear
      else:
         increment front
      return element
            </code></pre>
                    </section>
                </div>
            </article>

            <!-- Linked List Section -->
            <article class="ds-card">
                <h2>Linked List</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is a Linked List?</h3>
                        <p>A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>Dynamic memory allocation</li>
                            <li>Implementing stacks and queues</li>
                            <li>When frequent insertions/deletions are required</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>Music playlists</li>
                            <li>Image viewers</li>
                            <li>Web browser history</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="linkedlist-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="insert">Insert</button>
                            <button class="viz-btn" data-operation="delete">Delete</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: Linked List Operations

1. Create Node:
   node contains value and next pointer

2. Insert(position, element):
   create new node
   if position is start:
      new node's next = head
      head = new node
   else:
      traverse to position
      new node's next = current node's next
      current node's next = new node

3. Delete(position):
   if position is start:
      head = head's next
   else:
      traverse to position
      current node's next = current node's next's next
            </code></pre>
                    </section>
                </div>
            </article>

            <!-- Binary Tree Section -->
            <article class="ds-card">
                <h2>Binary Tree</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is a Binary Tree?</h3>
                        <p>A binary tree is a tree data structure where each node has at most two children, referred to as the left child and right child.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>Hierarchical data representation</li>
                            <li>Expression parsing</li>
                            <li>Huffman coding trees</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>File system directories</li>
                            <li>Organization hierarchies</li>
                            <li>Decision trees in machine learning</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="binarytree-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="insert">Insert</button>
                            <button class="viz-btn" data-operation="delete">Delete</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: Binary Tree Operations

1. Create Node:
   node contains value, left, and right pointers

2. Insert(root, value):
   if root is null:
      create new node
   else if value < root.value:
      insert in left subtree
   else if value > root.value:
      insert in right subtree

3. Delete(root, value):
   if root is null:
      return null
   if value < root.value:
      delete from left subtree
   else if value > root.value:
      delete from right subtree
   else:
      handle node deletion cases
            </code></pre>
                    </section>
                </div>
            </article>

            <!-- Binary Search Tree Section -->
            <article class="ds-card">
                <h2>Binary Search Tree (BST)</h2>
                <div class="ds-content">
                    <section class="ds-theory">
                        <h3>What is a Binary Search Tree?</h3>
                        <p>A BST is a binary tree where the left subtree of a node contains only nodes with keys less than the node's key, and the right subtree contains only nodes with keys greater than the node's key.</p>
                        
                        <h3>When to Use?</h3>
                        <ul>
                            <li>Efficient searching</li>
                            <li>Maintaining sorted data</li>
                            <li>Implementing map and set data structures</li>
                        </ul>

                        <h3>Real-life Applications</h3>
                        <ul>
                            <li>Database indexing</li>
                            <li>Autocomplete features</li>
                            <li>Priority queues</li>
                        </ul>
                    </section>

                    <section class="ds-visualization">
                        <h3>Visualization</h3>
                        <div class="canvas-container">
                            <canvas id="bst-viz"></canvas>
                        </div>
                        <div class="visualization-controls">
                            <button class="viz-btn" data-operation="insert">Insert</button>
                            <button class="viz-btn" data-operation="delete">Delete</button>
                        </div>
                    </section>

                    <section class="ds-implementation">
                        <h3>Implementation</h3>
                        <pre><code>
Algorithm: BST Operations

1. Search(root, value):
   if root is null or root.value equals value:
      return root
   if value < root.value:
      search left subtree
   else:
      search right subtree

2. Insert(root, value):
   if root is null:
      create new node
   if value < root.value:
      insert in left subtree
   else:
      insert in right subtree

3. Delete(root, value):
   find node to delete
   handle three cases:
   - Node with no children
   - Node with one child
   - Node with two children
            </code></pre>
                    </section>
                </div>
            </article>

            <!-- Heap Section -->
<article class="ds-card">
    <h2>Heap</h2>
    <div class="ds-content">
        <section class="ds-theory">
            <h3>What is a Heap?</h3>
            <p>A heap is a specialized tree-based data structure that satisfies the heap property. In a max heap, parent nodes are always greater than or equal to their children.</p>
            
            <h3>When to Use?</h3>
            <ul>
                <li>Priority queue implementation</li>
                <li>Sorting algorithms like Heap Sort</li>
                <li>Finding k-th largest/smallest elements</li>
            </ul>

            <h3>Real-life Applications</h3>
            <ul>
                <li>Operating system task scheduling</li>
                <li>Network routing algorithms</li>
                <li>Median maintenance</li>
            </ul>
        </section>

        <section class="ds-visualization">
            <h3>Visualization</h3>
            <div class="canvas-container">
                <canvas id="heap-viz"></canvas>
            </div>
            <div class="visualization-controls">
                <button class="viz-btn" data-operation="insert">Insert</button>
                <button class="viz-btn" data-operation="delete">Delete</button>
            </div>
        </section>

        <section class="ds-implementation">
            <h3>Implementation</h3>
            <pre><code>
Algorithm: Heap Operations

1. Insert(element):
   add element to end of heap
   heapify-up from bottom to top

2. Delete(root):
   replace root with last element
   remove last element
   heapify-down from top to bottom

3. Heapify-Up:
   compare element with parent
   swap if violates heap property
   repeat until heap property satisfied

4. Heapify-Down:
   compare element with children
   swap with largest/smallest child
   repeat until heap property satisfied</code></pre>
        </section>
    </div>
</article>

<!-- Graph Section -->
<article class="ds-card">
    <h2>Graph</h2>
    <div class="ds-content">
        <section class="ds-theory">
            <h3>What is a Graph?</h3>
            <p>A graph is a non-linear data structure consisting of vertices (nodes) and edges that connect these vertices. Graphs can be directed or undirected.</p>
            
            <h3>When to Use?</h3>
            <ul>
                <li>Social network connections</li>
                <li>Routing and navigation systems</li>
                <li>Dependency resolution</li>
            </ul>

            <h3>Real-life Applications</h3>
            <ul>
                <li>Google Maps routing</li>
                <li>Social media friend recommendations</li>
                <li>Network topology mapping</li>
            </ul>
        </section>

        <section class="ds-visualization">
            <h3>Visualization</h3>
            <div class="canvas-container">
                <canvas id="graph-viz"></canvas>
            </div>
            <div class="visualization-controls">
                <button class="viz-btn" data-operation="addnode">Add Node</button>
                <button class="viz-btn" data-operation="addedge">Add Edge</button>
            </div>
        </section>

        <section class="ds-implementation">
            <h3>Implementation</h3>
            <pre><code>
Algorithm: Graph Operations

1. Add Node(value):
   create new vertex with value
   add to graph's vertex list

2. Add Edge(source, destination):
   create edge between two vertices
   can be directed or undirected

3. Depth-First Search(start):
   mark start node as visited
   for each unvisited neighbor:
      recursively explore

4. Breadth-First Search(start):
   create queue, enqueue start
   mark start as visited
   while queue not empty:
      dequeue node
      explore unvisited neighbors</code></pre>
        </section>
    </div>
</article>

<!-- Hash Table Section -->
<article class="ds-card">
    <h2>Hash Table</h2>
    <div class="ds-content">
        <section class="ds-theory">
            <h3>What is a Hash Table?</h3>
            <p>A hash table is a data structure that implements an associative array or dictionary, using a hash function to compute an index into an array of buckets or slots.</p>
            
            <h3>When to Use?</h3>
            <ul>
                <li>Fast data retrieval</li>
                <li>Implementing caches</li>
                <li>Unique key-value storage</li>
            </ul>

            <h3>Real-life Applications</h3>
            <ul>
                <li>Database indexing</li>
                <li>Caching in web browsers</li>
                <li>Symbol tables in compilers</li>
            </ul>
        </section>

        <section class="ds-visualization">
            <h3>Visualization</h3>
            <div class="canvas-container">
                <canvas id="hashtable-viz"></canvas>
            </div>
            <div class="visualization-controls">
                <button class="viz-btn" data-operation="insert">Insert</button>
                <button class="viz-btn" data-operation="delete">Delete</button>
                <button class="viz-btn" data-operation="search">Search</button>
            </div>
        </section>

        <section class="ds-implementation">
            <h3>Implementation</h3>
            <pre><code>
Algorithm: Hash Table Operations

1. Hash Function:
   convert key to array index
   use modulo with table size

2. Insert(key, value):
   compute hash index
   handle collisions (chaining/open addressing)
   store key-value pair

3. Search(key):
   compute hash index
   traverse bucket/chain
   return value if found

4. Delete(key):
   compute hash index
   find and remove key-value pair
   handle potential collisions</code></pre>
        </section>
    </div>
</article>

       <!-- Trie Section -->
<article class="ds-card">
    <h2>Trie</h2>
    <div class="ds-content">
        <section class="ds-theory">
            <h3>What is a Trie?</h3>
            <p>A trie (prefix tree) is a tree-like data structure used to store a dynamic set of strings. Each node represents a character, and paths from root to leaf form complete words.</p>
            
            <h3>When to Use?</h3>
            <ul>
                <li>Autocomplete and spell checking</li>
                <li>Prefix matching</li>
                <li>IP routing tables</li>
            </ul>

            <h3>Real-life Applications</h3>
            <ul>
                <li>Search engine suggestions</li>
                <li>Dictionary implementations</li>
                <li>Phone contact search</li>
            </ul>
        </section>

        <section class="ds-visualization">
            <h3>Visualization</h3>
            <div class="canvas-container">
                <canvas id="trie-viz"></canvas>
            </div>
            <div class="visualization-controls">
                <button class="viz-btn" data-operation="insert">Insert</button>
                <button class="viz-btn" data-operation="search">Search</button>
                <button class="viz-btn" data-operation="delete">Delete</button>
            </div>
        </section>

        <section class="ds-implementation">
            <h3>Implementation</h3>
            <pre><code>
Algorithm: Trie Operations

1. Insert(word):
   traverse/create path for each character
   mark last node as end of word

2. Search(word):
   traverse path of characters
   check if last node marks end of word

3. Delete(word):
   find word's path
   remove word marker
   remove unused nodes</code></pre>
        </section>
    </div>
</article>

        </section>
    </main>

    <script src="/scripts/learn.js"></script>
    <script src="/scripts/auth.js"></script>
</body>
</html> 